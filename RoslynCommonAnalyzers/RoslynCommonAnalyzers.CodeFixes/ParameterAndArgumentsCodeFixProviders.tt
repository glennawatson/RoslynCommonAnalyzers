<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Runtime" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#

    var kinds = new (string Kind, string SyntaxNodeType, bool IsParameter, string TriviaContainerType, string BracketSymbol)[]
    {
        ("ConstructorDeclaration", "BaseMethodDeclarationSyntax", true, "ParameterList", "OpenParen"),
		("MethodDeclaration", "BaseMethodDeclarationSyntax", true, "ParameterList", "OpenParen"),
        ("DelegateDeclaration", "DelegateDeclarationSyntax", true, "ParameterList", "OpenParen"),
        ("IndexerDeclaration", "IndexerDeclarationSyntax", true, "BracketedParameterList", "OpenBracket"),
        ("InvocationExpression", "InvocationExpressionSyntax", false, "ArgumentList", "OpenParen"),
        ("ObjectCreationExpression", "ObjectCreationExpressionSyntax", false, "ArgumentList", "OpenParen"),
        ("ElementAccessExpression", "ElementAccessExpressionSyntax", false, "BracketedArgumentList", "OpenBracket"),
        ("Attribute", "AttributeSyntax", false, "AttributeArgumentList", "OpenParen"),
        ("AnonymousMethodExpression", "AnonymousMethodExpressionSyntax", true, "ParameterList", "OpenParen"),
        ("ParenthesizedLambdaExpression", "ParenthesizedLambdaExpressionSyntax", true, "ParameterList", "OpenParen"),
    };
#>
namespace RoslynCommonAnalyzers;

<#
int i = 1;
foreach (var (kind, syntaxNodeType, isParameter, containerType, bracketSymbol) in kinds)
{
    var code = $"RCGS{i:D4}";
    var parameterType = isParameter ? "Parameter" : "Argument";
    var className = $"{code}{parameterType}MustBeOnUniqueLinesCodeFixProvider";
    var accessMethod = isParameter ? "ParameterList" : "ArgumentList";
    var analyzerClassName = $"{code}{kind}{parameterType}MustBeOnUniqueLinesAnalyzer";
#>
[ExportCodeFixProvider(LanguageNames.CSharp, Name = nameof(<#=className#>)), Shared]
public class <#=className#> : CodeFixProvider
{
    public sealed override ImmutableArray<string> FixableDiagnosticIds => ImmutableArray.Create(<#=analyzerClassName#>.DiagnosticId);

    public sealed override FixAllProvider GetFixAllProvider() => WellKnownFixAllProviders.BatchFixer;

    public sealed override async Task RegisterCodeFixesAsync(CodeFixContext context)
    {
        var root = await context.Document.GetSyntaxRootAsync(context.CancellationToken).ConfigureAwait(false);

        if (root is null)
        {
            return;
        }

        foreach (var diagnostic in context.Diagnostics)
        {
            var node = root.FindNode(diagnostic.Location.SourceSpan);

            if (node is <#=syntaxNodeType#> syntaxNode)
            {
                // In this case there is no justification at all
                context.RegisterCodeFix(
                    CodeAction.Create(
                        CodeFixResources.RCGS0001CodeFixTitle,
                        token => Fix(context.Document, root, syntaxNode, context.CancellationToken),
                        nameof(<#=className#>) + "-Add"),
                    diagnostic);
                return;
            }
        }
    }

    private Task<Document> Fix(Document document, SyntaxNode root, <#=syntaxNodeType#> node, CancellationToken cancellationToken)
    {
        var newNode = node.ConvertNodeIfAble(
            node => node.<#=accessMethod#>?.<#=parameterType#>s,
            (node, parameters) => node.With<#=parameterType#>List(SyntaxFactory.<#=containerType#>(parameters).With<#=bracketSymbol#>Token(node.<#=parameterType#>List!.<#=bracketSymbol#>Token.WithTrailingTrivia(SyntaxFactory.ElasticCarriageReturnLineFeed))))
                ?? node;
        return Task.FromResult(document.WithSyntaxRoot(root.ReplaceNode(node, newNode)));
    }
}
<#
    i++;
}
#>